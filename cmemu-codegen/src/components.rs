use crate::components::conf::{ClockTreeNode, ClockTreeNodeConf, HandlerKind};
use crate::data_macros;
use anyhow::Context;
use conf::{BuildMetadata, CONFIG_FILE, ComponentConf, ComponentDesc, EmuConf, HandlerDesc};
use itertools::Itertools;
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};
use std::collections::HashMap;
use std::env;
use std::fmt::Write;
use std::fs;
use std::path::Path;
use std::process::Command;

mod clock_tree;
pub mod conf;
mod parsing;

const SKIP_ARGS_IN_HANDLERS: usize = 2; // self and ctx

// todo print more than one error?
// todo profile build script and make it faster if there's such a need?

pub fn analyze_components_generate_boilerplate() -> anyhow::Result<()> {
    let emu_conf: EmuConf = serde_yaml::from_reader(&fs::File::open(CONFIG_FILE)?)
        .context("cmemu build config is invalid")?;
    assert!(
        !emu_conf.device_tree.components.is_empty(),
        "emulator needs at least one component, check build config"
    );
    assert_eq!(
        emu_conf.device_tree.energy.proxy_type_name, "ClockTreeProxy",
        "ClockTree proxy must be named ClockTreeProxy, check build config",
    );
    emit_cargo_flags(&emu_conf);

    let components_index = conf::parse_components(emu_conf);

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_dir = Path::new(&out_dir);

    // Compiler infers function type of specific function (including it name),
    // so we need to let it know "the general" type.
    let recipe: &[(_, fn(_) -> _)] = &[
        ("build_data.rs", generate_build_data),
        ("component.rs", generate_component_mod),
        ("event_data_and_proxy.rs", generate_event_data_and_proxy_mod),
        ("emulator_handler_dispatch.rs", generate_handler_dispatch),
        ("clock_graph.rs", clock_tree::generate_clock_graph),
    ];

    for (mod_path, gen_mod_string) in recipe {
        let out_file = out_dir.join(mod_path);
        fs::write(&out_file, gen_mod_string(&components_index))?;
        drop(Command::new("rustfmt").arg(&out_file).status());
    }

    Ok(())
}

fn emit_cargo_flags(emu_conf: &EmuConf) {
    println!("cargo:rerun-if-changed={CONFIG_FILE}");
    println!("cargo:rerun-if-env-changed=CFG_RELEASE_CHANNEL");
    for c in &emu_conf.device_tree.components {
        println!("cargo:rerun-if-changed={}", c.file_path);
    }
}

// Less efficient, but more readable.
// And macro, since fmt string has to be statically known in compile time
macro_rules! format_components {
    ($comp_idx:ident $(($filter:expr))?, $elem_fmt_fn:expr) => {
        format_components!($comp_idx $(($filter))?, $elem_fmt_fn, "\n")
    };
    ($comp_idx:ident $(($filter:expr))?, $elem_fmt_fn:expr, $sep:expr) => {
        $comp_idx
            .components
            .iter()
            $(.filter($filter))?
            .map($elem_fmt_fn)
            .collect::<Vec<_>>()
            .join($sep)
    };
}

macro_rules! format_components_handlers {
    ($comp_idx:ident, $elem_fmt_fn:expr) => {
        format_components_handlers!($comp_idx, $elem_fmt_fn, "\n")
    };
    ($comp_idx:ident, $elem_fmt_fn:expr, $sep:expr) => {
        $comp_idx
            .components
            .iter()
            .map(|c| c.handlers.iter().map(move |h| $elem_fmt_fn(c, h)))
            .flatten()
            .collect::<Vec<_>>()
            .join($sep)
    };
}

macro_rules! format_handlers {
    ($comp:ident, $elem_fmt_fn:expr) => {
        format_handlers!($comp, $elem_fmt_fn, "\n")
    };
    ($comp:ident, $elem_fmt_fn:expr, $sep:expr) => {
        $comp
            .handlers
            .iter()
            .map($elem_fmt_fn)
            .collect::<Vec<_>>()
            .join($sep)
    };
}

/// `build_data` exports various data collected by the build script as enums and data-macros
fn generate_build_data(comp_idx: &BuildMetadata) -> String {
    let mut data = String::new();
    let out = &mut data;
    writeln!(out, "// Auto generated by a build script.").unwrap();

    // todo: this is wrong source, first iteration for simplicity
    let clock_types = comp_idx
        .energy
        .clock_tree
        .iter()
        .map(ClockTreeNodeConf::type_ident)
        .collect::<Vec<_>>();
    let oscillators = comp_idx
        .energy
        .oscillators
        .iter()
        .map(|o| format_ident!("{}", o.struct_name))
        .collect::<Vec<_>>();
    let component_types = comp_idx
        .components
        .iter()
        .map(|c| format_ident!("{}", c.config.struct_name()))
        .collect::<Vec<_>>();
    let proxies = comp_idx
        .components
        .iter()
        .map(|c| format_ident!("{}", c.config.proxy_type_name))
        .collect::<Vec<_>>();
    let features = comp_idx
        .components
        .iter()
        .map(|c| {
            if let Some(ref s) = c.config.requires_feature {
                quote!(#[cfg(feature=#s)])
            } else {
                quote! {}
            }
        })
        .collect::<Vec<_>>();
    let enums = build_data_enums(
        &clock_types,
        &oscillators,
        &component_types,
        &proxies,
        &features,
    );
    writeln!(out, "{enums}").unwrap();

    // Data-macros: tokens lists accessible by macros called in the main codebase
    writeln!(out, "{}", data_macros::INJECTED_MACROS).unwrap();
    // Export list of components as tokens in the form of `{ #[maybe_attribute] path::to::mod }`
    let components_list = data_macros::export_paths_list("components", {
        comp_idx
            .components
            .iter()
            .filter(|c| !c.is_special)
            .map(|c| {
                format!(
                    "{{ {} {} }}",
                    format_cfg_feature_if_present(&c.config),
                    &c.config.mod_path
                )
                .parse::<TokenStream>()
                .unwrap()
            })
    });
    writeln!(out, "{components_list}").unwrap();
    let nodes_list = data_macros::export_paths_list("clock_tree_nodes", clock_types.iter());
    writeln!(out, "{nodes_list}").unwrap();
    let osc_list = data_macros::export_paths_list("oscillators", oscillators.iter());
    writeln!(out, "{osc_list}").unwrap();
    let nodes_post = comp_idx
        .clock_graph
        .nodes_postorder()
        .filter_map(|n| match &*n {
            ClockTreeNode::Inner(i) => Some(format_ident!("{}", i.struct_name)),
            _ => None,
        });
    let post_list = data_macros::export_paths_list("clock_tree_nodes_postorder", nodes_post);
    writeln!(out, "{post_list}").unwrap();

    // Generate sublists per category to generate dispatchers
    let mut ct_categories: HashMap<_, Vec<_>> = HashMap::new();
    for ctnc in &comp_idx.energy.clock_tree {
        // TODO: IntoConstStr for kind
        ct_categories
            .entry(&ctnc.kind)
            .or_default()
            .push(ctnc.type_ident());
    }
    for (kind, list) in ct_categories {
        let kind_list =
            data_macros::export_paths_list(format!("clock_tree_nodes_{kind:?}"), list.iter());
        writeln!(out, "{kind_list}").unwrap();
    }

    data
}

fn build_data_enums(
    clock_types: &Vec<Ident>,
    oscillators: &Vec<Ident>,
    component_types: &Vec<Ident>,
    proxies: &Vec<Ident>,
    features: &Vec<TokenStream>,
) -> TokenStream {
    let types = quote! {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, enum_map::Enum, strum::IntoStaticStr)]
        #[non_exhaustive]
        pub(crate) enum Components {
            #(#component_types,)*
        }
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, enum_map::Enum, strum::IntoStaticStr)]
        #[non_exhaustive]
        pub(crate) enum ClockTreeNodes {
            #(#clock_types,)*
        }
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, enum_map::Enum, strum::IntoStaticStr)]
        #[non_exhaustive]
        pub(crate) enum Oscillators {
            #(#oscillators,)*
        }
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, enum_map::Enum, strum::IntoStaticStr)]
        #[non_exhaustive]
        pub(crate) enum EnergyEntity {
            Component(Components),
            ClockTree(ClockTreeNodes),
            Oscillator(Oscillators),
        }
    };
    let converters = quote! {
        #(
            #features
            impl crate::common::utils::FromMarker<crate::proxy::#proxies> for Components {
                fn from_marker() -> Components {
                    Components::#component_types
                }
                const MARKER_NAME: &'static str = stringify!(#component_types);
            }
            #features
            impl crate::common::utils::FromMarker<crate::proxy::#proxies> for EnergyEntity {
                fn from_marker() -> EnergyEntity {
                    EnergyEntity::Component(Components::#component_types)
                }
                const MARKER_NAME: &'static str = stringify!(#component_types);
            }
            #features
            impl From<&crate::proxy::#proxies> for EnergyEntity {
                fn from(_: &crate::proxy::#proxies) -> EnergyEntity {
                    EnergyEntity::Component(Components::#component_types)
                }
            }
        )*
    };
    quote! {
        #types
        #converters
    }
}

fn generate_component_mod(comp_idx: &BuildMetadata) -> String {
    assert!(
        comp_idx
            .components
            .iter()
            .any(|c| c.config.field_name == "flash"),
        "flash is a special component that has to be present"
    );
    let not_special = |&c: &&ComponentDesc| -> bool { !c.is_special };
    let fields = format_components!(comp_idx(not_special), |c| format!(
        "{} pub(crate) {}: {},",
        format_cfg_feature_if_present(&c.config),
        c.config.field_name,
        c.config.mod_path
    ));
    let fields_init = format_components!(comp_idx(not_special), |c| format!(
        "{} {}: {}::new({}),",
        format_cfg_feature_if_present(&c.config),
        c.config.field_name,
        c.config.mod_path,
        match c.config.field_name.as_ref() {
            "flash" => "flash_mem",
            "rom" => "rom_mem",
            _ => "",
        }
    ));
    let refs = format_components!(comp_idx(not_special), |c| format!(
        "{} impl AsMut<{}> for Components {{
            fn as_mut(&mut self) -> &mut {} {{
                &mut self.{}
            }}
        }}
        ",
        format_cfg_feature_if_present(&c.config),
        c.config.mod_path,
        c.config.mod_path,
        c.config.field_name,
    ));
    format!(
        "// Auto generated by build script.

        pub(crate) struct Components {{ {fields} }}

        impl Components {{
            pub(crate) fn new(flash_mem: &[u8], rom_mem: Option<&[u8]>) -> Self {{
                Self {{ {fields_init} }}
            }}
        }}

        {refs}
        "
    )
}

fn generate_event_data_and_proxy_mod(comp_idx: &BuildMetadata) -> String {
    let event_data_variants =
        format_components_handlers!(comp_idx, |c: &ComponentDesc, h: &HandlerDesc| -> String {
            match h.generator {
                HandlerKind::ClockTree | HandlerKind::Auto => format!(
                    "{} {}(super::proxy_{}::{}),",
                    format_cfg_feature_if_present(&c.config),
                    event_data_variant_name(c, h),
                    c.config.field_name,
                    event_data_variant_payload_type_name(c, h)
                ),
            }
        });
    format!(
        "// Auto generated by build script.

    pub(crate) mod event_data {{
        #![allow(non_camel_case_types)]
        use crate::component::WakeupEvent;

        {check_enabled}const _PAYLOAD_SIZE_CHECK: [(); {payload_size_check}] = [(); ::std::mem::size_of::<EventData>()];
        #[allow(dead_code)]
        pub(crate) const COMPONENTS_COUNT: usize = {components_count};
        #[allow(dead_code)]
        pub(crate) const HANDLERS_COUNT: usize = {handlers_count};

        #[derive(Debug)]
        pub(crate) enum EventData {{
            #[allow(unused)]
            Nop,
            Wakeup(WakeupEvent),
            {event_data_variants}
        }}
    }}


    {proxies}",
        check_enabled = if comp_idx.payload_size_check > 0 { "" } else { "// " },
        payload_size_check = comp_idx.payload_size_check,
        components_count = comp_idx.components.len(),
        handlers_count = comp_idx.components.iter().map(|c| c.handlers.len()).sum::<usize>(),
        proxies = format_components!(comp_idx, format_proxy, "\n\n"),
    )
}

fn format_proxy(component: &ComponentDesc) -> String {
    let methods = format_handlers!(
        component,
        |h| {
            match h.generator {
                HandlerKind::ClockTree |
                HandlerKind::Auto =>
            format!(
            "{attributes}
            #[inline]
            pub(crate) fn {handler_name}(&self, ctx: &mut Context, {delay_arg} {handler_args}) -> Option<EventRevokeToken> {{
                let payload = EventData::{payload_variant}({payload_data_type}({payload_data_fields}));
                #[cfg(debug_assertions)]
                if !ctx.get_energy_state::<Self>().is_active() {{
                ::log::debug!(\"Message to a disabled component: {payload_variant}: {{}}\", crate::printable!(payload));
                }}
                ctx.event_queue_mut().add({delay}, payload)
            }}",
            attributes = if h.allow_dead_code { "#[allow(dead_code)]" } else { "" },
            handler_name = h.name,
            delay_arg = if h.explicit_delay { "delay: Duration, " } else { "" },
            handler_args = h
                .fields
                .iter()
                .map(|(name, ty)| format!("{name}: {ty}"))
                .join(", "),
            payload_variant = event_data_variant_name(component, h),
            payload_data_type = event_data_variant_payload_type_name(component, h),
            payload_data_fields = h
                .fields
                .iter()
                .map(|(name, _)| name.clone())
                .collect::<Vec<_>>()
                .join(", "),
            delay = if h.explicit_delay { "delay" } else { "Duration::ZERO" },
            ),
            }
        },
        "\n\n"
    );
    let event_data_payload_structs = format_handlers!(component, |h| match h.generator {
        HandlerKind::ClockTree | HandlerKind::Auto => format!(
            "#[derive(Debug)] pub(crate) struct {}({});",
            event_data_variant_payload_type_name(component, h),
            h.fields
                .iter()
                .map(|(_, ty)| format!("pub(crate) {ty}"))
                .collect::<Vec<_>>()
                .join(", ")
        ),
    });
    format!(
        "{cfg_feature}
        pub(crate) use proxy_{field_name}::{proxy_name};
        {cfg_feature}
        #[allow(non_camel_case_types)]
        #[allow(unused_imports)] // it's really painful to split imports into two
        pub(crate) mod proxy_{field_name} {{
            #[allow(clippy::wildcard_imports)] // easier than parsing specific types needed by handlers
            use super::event_data::*;
            use crate::engine::{{Duration, EventRevokeToken}};
            {imports}
            #[allow(unused_imports)]
            use {mod_path};

            #[derive(Default)]
            pub(crate) struct {proxy_name};

            #[allow(clippy::used_underscore_binding)] // we use all bindings and use same names as user
            #[allow(clippy::unused_self)] // we want the proxy to be object-like
            impl {proxy_name} {{
                #[allow(dead_code)]
                pub(crate) fn new() -> Self {{
                    Self
                }}

                {methods}
            }}

            {event_data_payload_structs}
        }}",
        cfg_feature = format_cfg_feature_if_present(&component.config),
        field_name = component.config.field_name,
        proxy_name = component.config.proxy_type_name,
        imports = component.imports.join("\n    "),
        mod_path = component.config.mod_path,
    )
}

fn generate_handler_dispatch(comp_idx: &BuildMetadata) -> String {
    let handlers =
        format_components_handlers!(
            comp_idx,
            |c: &ComponentDesc, h: &HandlerDesc| match h.generator {
                HandlerKind::Auto | HandlerKind::ClockTree => {
                    format!(
                        "{cfg_feature}
            EventData::{payload_variant}(payload) => {{
                ::log::trace!(\"Dispatching {payload_variant}: {{}}\", crate::printable!(payload));
                self.{path}.{handler}(&mut self.context, {extra}{unpack});
            }}",
                        cfg_feature = format_cfg_feature_if_present(&c.config),
                        payload_variant = event_data_variant_name(c, h),
                        path = format_args!(
                            "{}{}",
                            if c.is_special { "" } else { "components." },
                            c.config.field_name
                        ),
                        handler = h.name,
                        unpack = h
                            .fields
                            .iter()
                            .enumerate()
                            .map(|(i, _val)| format!("payload.{i}"))
                            .collect::<Vec<_>>()
                            .join(", "),
                        extra = if h.pass_components {
                            "&mut self.components,"
                        } else {
                            ""
                        },
                    )
                }
            }
        );
    format!(
        "// Auto generated by build script.

        mod emu_handler_dispatch_impl {{
            #![allow(unused_braces, unused_qualifications)]
            #![allow(clippy::absolute_paths, clippy::inline_always, clippy::too_many_lines)]
            use crate::engine::Emulator;
            use crate::proxy::event_data::EventData;

            impl Emulator {{
                #[inline(always)]
                pub(super) fn dispatch_event(&mut self, payload: EventData) {{
                    match payload {{
                        EventData::Nop => (),
                        EventData::Wakeup(_) => unreachable!(\"Emulator::step_cycle() should've handled {{payload:?}}\"),
                        {handlers}
                    }}
                }}
            }}
        }}",
    )
}

// todo do we want to use CamelCase?
// https://docs.rs/Inflector/0.7.0/inflector/cases/classcase/index.html
// todo do we want to validate uniqueness of these names? it will fail to compile anyway, and it'll be easy to find the reason, anyway
fn event_data_variant_name(component: &ComponentDesc, handler: &HandlerDesc) -> String {
    format!("{}__{}", component.config.field_name, handler.name)
}

fn event_data_variant_payload_type_name(
    component: &ComponentDesc,
    handler: &HandlerDesc,
) -> String {
    format!("{}__{}__data", component.config.field_name, handler.name)
}

fn format_cfg_feature_if_present(config: &ComponentConf) -> String {
    format_cfg_feature(config.requires_feature.as_ref())
}

fn format_cfg_feature(required_feature: Option<&String>) -> String {
    if let Some(feature) = required_feature {
        format!("#[cfg(feature = \"{feature}\")]")
    } else {
        String::new()
    }
}
