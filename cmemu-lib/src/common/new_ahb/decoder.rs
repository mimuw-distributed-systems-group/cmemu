//! [`Decoder`] is a component deciding the routing from a single master to multiple slaves.
//!
//! The routing is based on address of the transfer.
//! The [`Decoder`] may need to split a transfer in two:
//!
//! - the data phase goes to one slave,
//! - the address phases may go to another one.
//!
//! Because of that, special considerations are needed.
//! Refer to the documentation of the [`Decoder`] struct for details.
use log::trace;
use std::fmt::{Debug, Display, Formatter};
use std::marker::PhantomData;

use crate::common::Address;
use crate::common::new_ahb::ports::{
    AHBMasterPortInput, AHBMasterPortOutput, AHBPortConfig, AHBSlavePortInput, AHBSlavePortOutput,
    AhbMasterPortInputWithGranting, AhbSlavePortOutputWithGranting, make_port_struct,
};
use crate::common::new_ahb::signals::{
    AhbResponseControl, BinaryWire, MasterToSlaveAddrPhase, MasterToSlaveDataPhase,
    MasterToSlaveWires, SlaveToMasterWires, TrackedBool,
};
use crate::common::new_ahb::vlan::{
    AHBMasterPortTaggedInput, AhbDecoderTag, AhbMasterOutputDispatcher,
};
use crate::common::utils::{FromMarker, SubcomponentProxyMut};
use crate::engine::{
    BufferFlop, CombFlop, Context, DisableableComponent, StateMachine, Subcomponent, TickComponent,
    TickComponentExtra, move_state_machine,
};

make_port_struct!(pub(crate) AhbPort<SC, PM>);

/// The AHB(-Lite) component routing and splitting transfers to multiple slaves.
///
/// The decoder has a single master and any number of slaves.
/// The exact behavior of an instance is configured with [`AhbDecoderTag`] which needs to
/// be implemented on each subcomponent-instance struct: `Decoder<SC>`.
///
/// The main invariants of the decoder are:
/// - data route must be kept until the transfer finishes,
/// - if addr router is different from data one, decoder must either reflect HREADY to addr phase
///   or DENY access (not propagate the addr route).
#[derive(Subcomponent, TickComponent, DisableableComponent)]
pub(crate) struct Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
{
    /// Slave that has the data phase active
    #[flop]
    data_port: CombFlop<<Self as AhbDecoderTag>::Enum>,
    /// Whether the data-phase has valid transfer (that is, not idle/nosel)
    #[flop]
    data_transfer_active: CombFlop<bool>,

    /// Hold the data until we get the reply with HREADY to reflect
    msg_buffer: Option<MasterToSlaveWires<<Self as AHBPortConfig>::Data>>,

    // Inlined "default slave" - routed when no address matches
    /// Data-phase response generated by the default slave, waiting to be propagated on tock
    #[flop]
    default_slave_out: BufferFlop<SlaveToMasterWires<<Self as AHBPortConfig>::Data>>,
    /// Address-phase corresponding to the default-slave-driven data-phase
    #[flop]
    default_slave_err_req: BufferFlop<MasterToSlaveAddrPhase>,
    phantom_sc: PhantomData<SC>,

    /// HREADY incoming from a slave side (data-phase wires)
    hreadyin: Option<BinaryWire>,
    /// The HREADY we sent to a slave side (addr-phase wires)
    hreadyout: Option<BinaryWire>,
    stm: DecoderSTM,
}

#[derive(Debug, PartialEq)]
enum DecoderSTM {
    Tick,
    GotS2M,
    GotM2S,
    End,
}

impl StateMachine for DecoderSTM {}

impl<SC> Default for Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag
        + AHBSlavePortOutput<Component = SC::Component>
        + AhbMasterOutputDispatcher<<Self as AhbDecoderTag>::Enum>,
    <Self as AHBPortConfig>::Data: Default,
{
    fn default() -> Self {
        const {
            // Post mono error, but still better than runtime!
            assert!(
                <Self as AhbDecoderTag>::REFLECTS_HREADY
                    || <Self as AhbDecoderTag>::GRANTER.is_some(),
                "Decoder need GRANTER when !REFLECTS_HREADY is set"
            );
        }
        Self {
            data_port: CombFlop::new_from(FromMarker::<DefaultSlave>::from_marker()),
            data_transfer_active: CombFlop::new(),
            msg_buffer: None,
            // Start the first cycle with an empty response
            default_slave_out: BufferFlop::new_from(SlaveToMasterWires::empty::<
                AhbPort<SC, DefaultSlave>,
            >()),
            default_slave_err_req: BufferFlop::new(),
            phantom_sc: PhantomData,
            hreadyin: None,
            hreadyout: None,
            stm: DecoderSTM::End,
        }
    }
}

pub(crate) trait AhbDecode {
    fn decode(addr: Address) -> Self;
}
#[derive(Debug, Default)]
pub(crate) struct DefaultSlave;

impl<SC> TickComponentExtra for Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
{
    #[cfg(debug_assertions)]
    fn tick_assertions(&self) {
        assert!(
            self.msg_buffer.is_none(),
            "Message buffer not consumed: {:?}",
            self.msg_buffer
        );
        if <Self as AhbDecoderTag>::REFLECTS_HREADY {
            match (self.hreadyin, self.hreadyout) {
                (Some(true), Some(false)) => {
                    panic!("{self}: HREADYIN was not properly reflected with LOW HREADYOUT!")
                }
                (None, Some(false)) => panic!("{self}: No input reflection with LOW HREADYOUT!"),
                _ => (),
            }
        }
    }

    fn tick_extra(&mut self) {
        {
            self.hreadyout = None;
            self.hreadyin = None;
        }
        {
            self.stm = DecoderSTM::Tick;
            // move_state_machine!(self.stm => DecoderSTM = {End | GotS2M | Tick => DecoderSTM::Tick});
        }
        self.data_port.default_keep_current_as_next();
        // TODO: maybe those should be FlopMemoryBanks actually?
        self.data_transfer_active.map_or((), |_| ());
    }
}

impl<SC> Decoder<SC>
where
    SC: Subcomponent<Member = Decoder<SC>>,
    Self: AhbDecoderTag
        + AHBSlavePortOutput<Component = SC::Component>
        + AhbMasterOutputDispatcher<<Self as AhbDecoderTag>::Enum>,
    <Self as AHBPortConfig>::Data: Default,
{
    // TODO: remove this trick: we use sub-tick here to allow implementing TickComponent on directly on Decoder<sth>
    pub(crate) fn sub_tick(_comp: &mut SC::Component, _ctx: &mut Context) {}
    pub(crate) fn new() -> Self {
        Default::default()
    }

    pub(crate) fn tock(comp: &mut SC::Component, ctx: &mut Context) {
        let mut this = SubcomponentProxyMut::<SC>::from(comp);
        if let Some(out) = this.default_slave_out.try_take() {
            <AhbPort<SC, DefaultSlave> as AHBMasterPortInput>::on_ahb_input(
                this.component_mut(),
                ctx,
                out,
            );
        }
    }
}

impl<SC> AHBSlavePortInput for Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag
        + AHBSlavePortOutput<Component = SC::Component>
        + AhbMasterOutputDispatcher<<Self as AhbDecoderTag>::Enum>,
    <Self as AHBPortConfig>::Data: Debug,
{
    fn on_ahb_input(
        comp: &mut Self::Component,
        ctx: &mut Context,
        msg: MasterToSlaveWires<Self::Data>,
    ) {
        let mut this = SC::get_proxy(comp);
        this.hreadyin = Some(msg.addr_phase.ready);

        move_state_machine!(this.stm => DecoderSTM = {
            GotS2M => End,
            Tick => GotM2S,
        });
        if !<Self as AhbDecoderTag>::REFLECTS_HREADY
            || this.hreadyout.is_some()
            || !this.data_transfer_active.is_set_and(|x| *x)
        {
            // No need to wait (we're not reflecting, have the value, or expect no response)
            Self::deliver_m2s(this.component_mut(), ctx, msg);
        } else {
            this.msg_buffer = Some(msg);
        }
    }
}

// Response from our slave -- one of the output stages or just standalone component.
impl<SC> AHBMasterPortTaggedInput for Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag
        + AHBSlavePortOutput<Component = SC::Component>
        + AhbMasterOutputDispatcher<<Self as AhbDecoderTag>::Enum>,
{
    fn on_ahb_tagged_input(
        comp: &mut Self::Component,
        ctx: &mut Context,
        tag: Self::Enum,
        msg: SlaveToMasterWires<Self::Data>,
    ) {
        let mut this = SC::get_proxy(comp);
        if tag == *this.data_port {
            {
                this.hreadyout = Some(msg.meta.HREADYOUT());
                move_state_machine!(this.stm => DecoderSTM = {
                    GotM2S => End,
                    Tick => GotS2M
                });
            }
            if msg.meta.is_waitstate() {
                // No advancement, but we should also reflect this.
                this.data_port.keep_current_as_next();
                this.data_transfer_active.keep_current_as_next();
            }
            <Self as AHBSlavePortOutput>::send_ahb_output(this.component_mut(), ctx, msg);

            // Deliver buffered message
            if let Some(msg) = this.msg_buffer.take() {
                Self::deliver_m2s(this.component_mut(), ctx, msg);
            }
        } else {
            debug_assert!(
                msg.meta.is_done(),
                "{}: Non-data phase slave sent non-success",
                *this
            );
        }
    }
}

impl<SC> Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag
        + AHBSlavePortOutput<Component = SC::Component>
        + AhbMasterOutputDispatcher<<Self as AhbDecoderTag>::Enum>,
    <Self as AHBPortConfig>::Data: Debug,
{
    // If we're here, a message came from current downstream or was not required (i.e., must reply HREADY)
    // We may need to send two messages: one to the current data phase and one to the next addr phase
    fn deliver_m2s(
        comp: &mut <Self as AHBPortConfig>::Component,
        ctx: &mut Context,
        mut msg: MasterToSlaveWires<<Self as AHBPortConfig>::Data>,
    ) {
        let mut this = SC::get_proxy(comp);
        let data_port = *this.data_port;

        if <Self as AhbDecoderTag>::REFLECTS_HREADY {
            msg.addr_phase.ready &= this.hreadyout.is_none_or(|x| x);
        }

        let addr_tag = if let Some(meta) = msg.addr_phase.meta.meta() {
            <Self as AhbDecoderTag>::dynamic_decode(this.component_mut(), ctx, meta)
        } else if msg.addr_phase.meta.is_idle() {
            data_port
        } else {
            FromMarker::<DefaultSlave>::from_marker()
        };

        if msg.addr_phase.ready {
            // may be latched in output
            this.data_port.set_next_if_not_latching(addr_tag);
            this.data_transfer_active
                .set_default_next(msg.addr_phase.advances_to_valid());
        }

        trace!(
            "Decoder {:} routes addr {:?} to {:?} and data {:?}.",
            *this,
            msg.addr_phase.meta.address(),
            addr_tag,
            this.data_port
        );

        if addr_tag == data_port {
            // easy-peasy
            trace!("{} to {:?} sends {:?}", *this, addr_tag, msg);
            Self::dispatch_ahb_output(this.component_mut(), ctx, addr_tag, msg);
        } else {
            let MasterToSlaveWires {
                addr_phase,
                data_phase,
            } = msg;
            let for_mux_data = MasterToSlaveWires {
                addr_phase: MasterToSlaveAddrPhase::not_selected::<Self>()
                    .with_hready(addr_phase.ready),
                data_phase,
            };
            let for_sel_addr = MasterToSlaveWires {
                addr_phase,
                data_phase: MasterToSlaveDataPhase::empty::<Self>(),
            };

            // If we can safely send addr phase to something else
            if <Self as AhbDecoderTag>::REFLECTS_HREADY // because we reflect HREADY
                || !this.data_transfer_active.is_set_and(|f| *f)
            // or no transfer is active
            {
                // then we can just send it...
                trace!(
                    "Decoder {:} to {:?} sends {:?}",
                    *this, addr_tag, for_sel_addr
                );
                Self::dispatch_ahb_output(this.component_mut(), ctx, addr_tag, for_sel_addr);
            } else {
                // otherwise, data phase HREADY may be LOW, but we would send a ready transfer
                // to the addr route, which would advance... and we would have two data phases!
                // The only other option is to DENY access like the granter would!
                <Self as AhbDecoderTag>::GRANTER
                    .expect("Decoder need GRANTER when !REFLECTS_HREADY is set")(
                    this.component_mut(),
                    ctx,
                    TrackedBool::false_::<Self>(),
                );
            }

            // Data-phase is always safe to send.
            trace!(
                "Decoder {:} to {:?} sends {:?}",
                *this, data_port, for_mux_data
            );
            Self::dispatch_ahb_output(this.component_mut(), ctx, data_port, for_mux_data);
        }
    }
}

// Convert type-based connections to tag-based input-output with slaves.
impl<SC, M> AHBMasterPortInput for AhbPort<SC, M>
where
    SC: Subcomponent<Member = Decoder<SC>>,
    Self: AHBPortConfig<Component = SC::Component, Data = <Decoder<SC> as AHBPortConfig>::Data>,
    Decoder<SC>: AHBMasterPortTaggedInput,
    Decoder<SC>: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
    // + AhbMasterOutputDispatcher<<Decoder<SC> as AhbDecoderConfig>::Enum>,
    <Decoder<SC> as AhbDecoderTag>::Enum: FromMarker<M>,
{
    #[inline]
    fn on_ahb_input(
        comp: &mut Self::Component,
        ctx: &mut Context,
        msg: SlaveToMasterWires<Self::Data>,
    ) {
        let tag = <<Decoder<SC> as AhbDecoderTag>::Enum as FromMarker<M>>::from_marker();
        Decoder::<SC>::on_ahb_tagged_input(comp, ctx, tag, msg);
    }
}

// Grant wire connections with the Output Stages
impl<SC, M> AhbMasterPortInputWithGranting for AhbPort<SC, M>
where
    SC: Subcomponent<Member = Decoder<SC>>,
    Self: AHBPortConfig<Component = SC::Component, Data = <Decoder<SC> as AHBPortConfig>::Data>,
    Decoder<SC>: AHBMasterPortTaggedInput,
    Decoder<SC>: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
    <Decoder<SC> as AhbDecoderTag>::Enum: FromMarker<M>,
    Decoder<SC>: AhbSlavePortOutputWithGranting,
{
    #[inline]
    fn on_grant_wire(comp: &mut Self::Component, ctx: &mut Context, granted: TrackedBool) {
        let mut this = SC::get_proxy(comp);
        if !*granted {
            this.data_transfer_active.set_next_if_not_latching(false);
        }
        Decoder::<SC>::send_grant_wire(this.component_mut(), ctx, granted);
    }
}

impl<SC> Display for Decoder<SC>
where
    SC: Subcomponent<Member = Self>,
    Self: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", <Self as AHBPortConfig>::TAG)
    }
}

//

impl<SC, M> AHBPortConfig for AhbPort<SC, M>
where
    SC: Subcomponent<Member = Decoder<SC>>,
    Decoder<SC>: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
    // + AhbMasterOutputDispatcher<<Decoder<SC> as AhbDecoderConfig>::Enum>,
    <Decoder<SC> as AhbDecoderTag>::Enum: FromMarker<M>,
{
    type Data = <Decoder<SC> as AHBPortConfig>::Data;
    type Component = SC::Component;
    const TAG: &'static str = <<Decoder<SC> as AhbDecoderTag>::Enum as FromMarker<M>>::MARKER_NAME;
}

impl<SC> AHBMasterPortOutput for AhbPort<SC, DefaultSlave>
where
    SC: Subcomponent<Member = Decoder<SC>>,
    Decoder<SC>: AhbDecoderTag + AHBSlavePortOutput<Component = SC::Component>,
{
    fn send_ahb_output(
        comp: &mut Self::Component,
        _ctx: &mut Context,
        msg: MasterToSlaveWires<Self::Data>,
    ) {
        let mut this = SubcomponentProxyMut::<SC>::from(comp);
        let (response, source_msg, data) = if let Some(err_msg) =
            this.default_slave_err_req.try_take()
        {
            (AhbResponseControl::Error2, err_msg, None)
        } else if msg.addr_phase.ready && msg.addr_phase.meta.is_address_valid() {
            if let Some(data) = <Decoder<SC> as AhbDecoderTag>::stateless_mock(&msg.addr_phase) {
                (AhbResponseControl::Success, msg.addr_phase, Some(data))
            } else {
                paranoid!(
                    warn,
                    "Addr {:?} routed to a default slave {} (returning error)",
                    msg.addr_phase,
                    <Self as AHBPortConfig>::TAG
                );
                this.default_slave_err_req.set_next(msg.addr_phase.clone());
                (AhbResponseControl::Error1, msg.addr_phase, None)
            }
        } else {
            (AhbResponseControl::Success, msg.addr_phase, None)
        };
        this.default_slave_out
            .set_next(source_msg.make_reply::<Self, _>(response, data.unwrap_or_default()));
    }
}
