use cc2650_constants::{FLASH, TRNG, WDT, is_unbuffered_alias};
use cmemu_common::address_match_range;
use cmemu_proc_macros::{component_impl, handler, proxy_use};

use crate::bridge_ports;
use crate::common::Address;
use crate::common::new_ahb::databus::DataBus;
use crate::common::new_ahb::ports::AHBSlavePortProxiedInput;
#[proxy_use]
use crate::common::new_ahb::ports::{AHBPortConfig, AHBSlavePortInput};
#[proxy_use]
use crate::common::new_ahb::signals::{MasterToSlaveWires, Size};
use crate::common::new_ahb::slave_driver::WriteMode;
use crate::common::new_ahb::slave_driver::faking_slave_driver::{
    AlignedFakingHandler, FakingIface, WaitstatesOrErr,
};
use crate::common::utils::MaybeMut;
#[proxy_use]
use crate::engine::Context;
use crate::engine::{
    DisableableComponent, MainComponent, SkippableClockTreeNode, TickComponent, TickComponentExtra,
};
use crate::proxy::MemoryMockProxy;
use log::trace;

mod autogenerated;
use autogenerated::AutoMockComponent;
// This file contains some references, specific to data mocking.
//
// WHIP6-PUB: references to code in whip6-pub repo
// (commit hash: 0fc691eb673afc11884306a32c3bd0f27da03531),
// paths are relative to `nesc/whip6` inside whip6-pub repo.
//
// WEB: reference to some web resource
// It's better than nothing but it may become unavailable in the future.

#[derive(MainComponent, SkippableClockTreeNode, TickComponent, TickComponentExtra)]
#[skippable_if_disableable]
pub(crate) struct MemoryMockComponent {
    #[subcomponent(DriverSC)]
    slave_driver: BusDriver,

    #[subcomponent(AutoMockComponent)]
    pub(crate) automock: AutoMockComponent,

    rng: fastrand::Rng,
}

type BusDriver = FakingIface<DriverSC, MemoryMockComponent>;

#[component_impl(mem_mock)]
impl MemoryMockComponent {
    pub(crate) fn new() -> Self {
        Self {
            slave_driver: BusDriver::new(),
            automock: AutoMockComponent::new(),
            rng: fastrand::Rng::with_seed(0),
        }
    }

    pub(crate) fn tick(&mut self, ctx: &mut Context) {
        BusDriver::run_driver(self, ctx);
    }

    pub(crate) fn tock(&mut self, ctx: &mut Context) {
        BusDriver::tock(self, ctx);
        if self.automock.trng_swreset.bitfields().RESET() != 0 {
            // this should take 4-5 cycles but the perceivable difference is probably negligible
            self.automock.trng_swreset.set_next(
                self.automock
                    .trng_swreset
                    .mutate_copy(|bf| bf.with_RESET(0)),
            );
        }
    }

    pub(crate) fn set_rng_seed(&mut self, seed: u64) {
        self.rng.seed(seed);
    }

    #[handler]
    pub fn on_new_ahb_slave_input(
        &mut self,
        ctx: &mut Context,
        msg: MasterToSlaveWires<<MemoryMockComponent as AHBPortConfig>::Data>,
    ) {
        <Self as AHBSlavePortInput>::on_ahb_input(self, ctx, msg);
    }
}

bridge_ports!(@slave MemoryMockComponent => @auto_configured @slave BusDriver);

#[component_impl(mem_mock)]
impl AHBPortConfig for MemoryMockComponent {
    type Data = DataBus;
    type Component = Self;
    const TAG: &'static str = "MemoryMock";
}

#[component_impl(mem_mock)]
impl AHBSlavePortProxiedInput for MemoryMockComponent {
    fn proxy_ahb_input(ctx: &mut Context, msg: MasterToSlaveWires<Self::Data>) {
        MemoryMockProxy.on_new_ahb_slave_input(ctx, msg);
    }
}
#[component_impl(mem_mock)]
impl AlignedFakingHandler for MemoryMockComponent {
    const WRITE_MODE: WriteMode = WriteMode::Combinatorial;
    const ALIGN: Size = Size::Word;
    type Native = [u8; 4];

    fn read_for_write_filler(
        slave: &Self::Component,
        ctx: &Context,
        address: Address,
    ) -> Self::Native {
        Self::get_data_for_address(MaybeMut::Ref(slave), ctx, address)
    }

    fn pre_read(
        slave: &mut Self::Component,
        _ctx: &mut Context,
        address: Address,
    ) -> WaitstatesOrErr {
        Ok(slave.get_waitstates_for_address(address, false))
    }

    fn read(slave: &mut Self::Component, ctx: &mut Context, address: Address) -> Self::Native {
        // Note: this differs from read_for_write_filler due to mutability
        Self::get_data_for_address(MaybeMut::Mut(slave), ctx, address)
    }

    fn pre_write(
        slave: &mut Self::Component,
        _ctx: &mut Context,
        address: Address,
    ) -> WaitstatesOrErr {
        Ok(slave.get_waitstates_for_address(address, true))
    }

    fn write(slave: &mut Self::Component, ctx: &mut Context, address: Address, data: Self::Native) {
        slave.set_data_for_address(address, data, ctx);
    }
}

#[component_impl(mem_mock)]
impl DisableableComponent for MemoryMockComponent {
    fn can_be_disabled_now(&self) -> bool {
        true
    }
}

#[component_impl(mem_mock)]
impl MemoryMockComponent {
    fn get_waitstates_for_address(&mut self, addr: Address, _writing: bool) -> u8 {
        debug_assert!(is_unbuffered_alias(addr).is_none());

        if cfg!(not(feature = "nm-unstable")) {
            // TODO: waitstating is bugged, since pre_write is registered and write_data is combinatorial
            //  (that is, these two may be called in the same cycle if we return 1 for write)
            return 0;
        }

        address_match_range! {addr,
            FLASH::BASE_ADDR => 2,
            FLASH::FRDCTL::ADDR => 5,
            _ => 0,
        }
    }

    // Mutability of MaybeMut may be confusing, but it indicates if side effects are allowed.
    // We need a mut smart pointer to get a mut reference from it.
    fn get_data_for_address(
        mut this: MaybeMut<Self>,
        #[allow(unused)] ctx: &Context,
        addr: Address,
    ) -> [u8; 4] {
        if let Some(data) = AutoMockComponent::get_data_for_address(this.project(), addr) {
            trace!(
                "*0x{addr:?} -> {data:02X?} {}",
                ctx.display_named_address(addr)
            );
            return data;
        }
        if let (Some(this), TRNG::OUT0::ADDR | TRNG::OUT1::ADDR) = (this.get_mut(), addr) {
            return this.rng.u32(..).to_le_bytes();
        }
        unimplemented!(
            "Requested mem_mock data read from address {:?} {}",
            addr,
            ctx.display_named_address(addr)
        )
    }

    fn set_data_for_address(
        &mut self,
        addr: Address,
        data: [u8; 4],
        #[allow(unused)] ctx: &mut Context,
    ) {
        if let Some(()) = self.automock.set_data_for_address(addr, data) {
            if addr != WDT::ICR::ADDR {
                // spammy!
                trace!(
                    "*0x{addr:?} <- {data:02X?} {}",
                    ctx.display_named_address(addr)
                );
            }
        } else {
            unimplemented!(
                "Requested mem_mock data write {:02X?} to address {:?} {}",
                data,
                addr,
                ctx.display_named_address(addr)
            )
        }
    }
}
